一.使用内置tomcat启动
启动方式：
1、IDEA中main函数启动
2、mvn springboot-run 命令
3、java -jar XXX.jar

使用第三种时，为保证服务在后台运行，会使用nohup
nohup java -jar web.jar --spring.profiles.active=dev

nohup介绍
nohup 是 no hang up 的缩写，
就是不挂断的意思。

用途：不挂断地运行命令
语法：nohup Command [ Arg … ] [　& ]
描述：nohup 命令运行由 Command 参数和任何相关的 Arg 参数指定的命令，
忽略所有挂断（SIGHUP）信号。在注销后使用 nohup 命令运行后台中的程序。
要运行后台中的 nohup 命令，添加 & （ 表示“and”的符号）到命令的尾部。



配置内置tomcat属性：
关于Tomcat的属性都在org.springframework.boot.autoconfigure.web.ServerProperties配置类中做了定义，
我们只需在application.properties配置属性做配置即可。
通用的Servlet容器配置都已”server”左右前缀，
而Tomcat特有配置都以”server.tomcat”作为前缀。下面举一些常用的例子。

配置Servlet容器：
#配置程序端口，默认为8080
server.port= 8080
#用户绘画session过期时间，以秒为单位
server.session.timeout=
# 配置默认访问路径，默认为/
server.context-path=

# 配置Tomcat编码,默认为UTF-8
server.tomcat.uri-encoding=UTF-8
# 配置最大线程数
server.tomcat.max-threads=1000


二.使用外置tomcat部署
配置步骤：
1、继承SpringBootServletInitializer
外部容器部署的话，就不能依赖于Application的main函数了，
而是要以类似于web.xml文件配置的方式来启动Spring应用上下文，
此时我们需要在启动类中继承SpringBootServletInitializer并实现configure方法：

package com.zjt.chapter05;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.boot.builder.SpringApplicationBuilder;
import org.springframework.boot.web.support.SpringBootServletInitializer;

@SpringBootApplication
public class Chapter05Application extends SpringBootServletInitializer {
    @Override
    protected SpringApplicationBuilder configure(SpringApplicationBuilder application) {
        return application.sources(Chapter05Application.class);
    }
    public static void main(String[] args) {
        SpringApplication.run(Chapter05Application.class, args);
    }
}
这个类的作用与在web.xml中配置负责初始化Spring应用上下文的监听器作用类似，
只不过在这里不需要编写额外的XML文件了。

2、pom.xml修改tomcat相关的配置
　　首先介绍下maven中scope依赖范围的概念，因为后续涉及到这个会有问题。
　　依赖范围就是用来控制依赖和三种classpath(编译classpath，测试classpath、运行classpath)的关系，
    Maven有如下几种依赖范围：

compile:编译依赖范围。
        如果没有指定，就会默认使用该依赖范围。
        使用此依赖范围的Maven依赖，对于编译、测试、运行三种classpath都有效。
        典型的例子是spring-code,在编译、测试和运行的时候都需要使用该依赖。

test:   测试依赖范围。
        使用次依赖范围的Maven依赖，只对于测试classpath有效，
        在编译主代码或者运行项目的使用时将无法使用此依赖。
        典型的例子是Jnuit,它只有在编译测试代码及运行测试的时候才需要。

provided:已提供依赖范围。
        使用此依赖范围的Maven依赖，对于编译和测试classpath有效，但在运行时候无效。
        典型的例子是servlet-api,编译和测试项目的时候需要该依赖，但在运行项目的时候，
        由于容器以及提供，就不需要Maven重复地引入一遍。

如果要将最终的打包形式改为war的话，还需要对pom.xml文件进行修改，
因为spring-boot-starter-web中包含内嵌的tomcat容器，
所以直接部署在外部容器会冲突报错。这里有两种方法可以解决，如下

方法一：排除内置tomcat
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-web</artifactId>
    <exclusions>
        <exclusion>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-tomcat</artifactId>
        </exclusion>
    </exclusions>
</dependency>

在这里需要移除对嵌入式Tomcat的依赖，这样打出的war包中，
在lib目录下才不会包含Tomcat相关的jar包，否则将会出现启动错误。

还有一个很关键的关键点，就是tomcat-embed-jasper中scope必须是provided。
<dependency>
    <groupId>org.apache.tomcat.embed</groupId>
    <artifactId>tomcat-embed-jasper</artifactId>
    <scope>provided</scope>
</dependency>

因为SpringBootServletInitializer需要依赖 javax.servlet，
而tomcat-embed-jasper下面的tomcat-embed-core中就有这个javax.servlet，
如果没用provided，最终打好的war里面会有servlet-api这个jar，
这样就会跟tomcat本身的冲突了。
这个关键点同样适应于下面说的第二种方法。


方法二：
直接添加如下配置即可：
<!--部署成war包时开启↓↓↓↓-->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-tomcat</artifactId>
            <scope>provided</scope>
        </dependency>
        <dependency>
            <groupId>org.apache.tomcat.embed</groupId>
            <artifactId>tomcat-embed-jasper</artifactId>
            <scope>provided</scope>
        </dependency>
<!--部署成war包时开启↑↑↑↑-->
provided的作用上面已经介绍的很透彻了, 这种方式的好处是，
打包的war包同时适合java -jar命令启动以及部署到外部容器中。


3、由jar变成war
<packaging>war</packaging>

4、注意的问题
此时打成的包的名称应该和application.properties的
server.context-path=/test

保持一致
<build>
    <finalName>test</finalName>
</build>
如果不一样发布到tomcat的webapps下上下文会变化
