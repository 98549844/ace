JDK collections - 使用

1） 排序（Sort）
    Collections.sort(list);
2） 混排（Shuffling）
   Collections.shuffle(list);
3） 反转（Reverse）
    Collections. reverse (list);
4） 填充所有的元素（Fill）
    Collections.fill(list,"aaa");
5） 拷贝（Copy）
    Collections.copy(listDes,listSrc);
    将listSrc的内容拷贝到listDes中，从第一个起将会覆盖listDes中的元素
6） 返回Collections中最小元素（min）
    Collections.min(list);
7） 返回Collections中最大元素（max）
    Collections.max(list);
8） IndexOfSubList
    Collections.indexOfSubList(list,subList);
9） lastIndexOfSubList
    Collections. lastIndexOfSubList (list,subList);
10） Rotate 根据指定的距离循环移动指定列表中的元素
    Collections.rotate(list,-1);  如果是负数，则正向移动，正数则反向移动



Thread源码介绍

概述
深入的介绍了JDK源码中，Thread对象的几个常用细节点，
以加深对其内部原理的认识。夯实读者Java基础知识。

分析
基本介绍
Thread是Java中重要的一个类，它是实现多线程的重要成员，也是多线程的开启者。
每一个线程都有优先级，优先级高的线程通常是先于优先级低的线程执行。

每一个线程可以被标注成守护线程（Java中线程分为守护线程和非守护线程，
当非守护线程执行完毕后，只剩下守护线程时，虚拟机会退出应用）。
默认情况下，开启的线程
为非守护线程。线程的开启为start方法，开启线程后，
执行的代码为run方法，需要override run方法。
有两种实现线程的方式，一是：继承Thread类，
另一种是实现Runnable接口，



HashMap实现原理
HashMap的主干是一个Entry数组。Entry是HashMap的基本组成单元，每一个Entry包含一个key-value键值对。

简单来说，HashMap由数组+链表组成的，数组是HashMap的主体，
链表则是主要为了解决哈希冲突而存在的，如果定位到的数组位置不含链表（当前entry的next指向null）,
那么对于查找，添加等操作很快，仅需一次寻址即可；
如果定位到的数组包含链表，对于添加操作，其时间复杂度为O(n)，
首先遍历链表，存在即覆盖，否则新增；对于查找操作来讲，
仍需遍历链表，然后通过key对象的equals方法逐一比对查找。
所以，性能考虑，HashMap中的链表出现越少，性能才会越好。


Java 反射详解

什么是反射？　
　　Java反射就是在运行状态中，对于任意一个类，
都能够知道这个类的所有属性和方法；对于任意一个对象，
都能够调用它的任意方法和属性；并且能改变它的属性。
而这也是Java被视为动态
（或准动态，为啥要说是准动态，因为一般而言的动态语言定义是程序运行时，
允许改变程序结构或变量类型，这种语言称为动态语言。
从这个观点看，Perl，Python，Ruby是动态语言，C++，Java，C#不是动态语言。）
语言的一个关键性质。


反射能做什么？
　　我们知道反射机制允许程序在运行时取得任何一个已知名称的class的内部信息，
包括包括其modifiers(修饰符)，fields(属性)，methods(方法)等，
并可于运行时改变fields内容或调用methods。那么我们便可以更灵活的编写代码，
代码可以在运行时装配，无需在组件之间进行源代码链接，
降低代码的耦合度；还有动态代理的实现等等；但是需要注意的是反射使用不当会造成很高的资源消耗！

反射总结
灵活使用反射能让我们代码更加灵活，这里比如JDBC原生代码注册驱动，
hibernate 的实体类，Spring 的 AOP等等都有反射的实现。
但是凡事都有两面性，反射也会消耗系统的性能，增加复杂性等，合理使用才是真！